<!--
@license
Copyright (c) 2017 Swarm City
This code may only be used under the license found at https://github.com/swarmcity/license
-->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">


<!--
An element that provides simple access an IPFS gateway

HTML Example:
```
<data-ipfs id="ipfs"></data-ipfs>
```
JS Example
```
this.$.ipfs.postFile()
.then((ipfsHash) => {
    console.log(ipfsHash) 
})
```

-->

<dom-module id="data-ipfs">
    <script>
        class DataIPFS extends Polymer.Element {
            static get is() { return 'data-ipfs'; }

/**
* sends an image file to an IPFS provider
* @param {base64} base64 of the object to send to an IPFS provider.
* @return {ipfsHash} returns saved acocunt.
*/
    postFile(base64) {
        return new Promise((resolve, reject) => {
            const file = base64;
            this._providers()
            .then((providers) => {
                return Promise.all([this._healthCheck(providers), this._buffer(file)]);
            })
            .then((data) => {
                const provider = data[0].rpc;
                const buffer = data[1];
                return this._sendFile(provider, buffer);
            })
            .then((ipfsHash) => {
                const len = encodeURI(ipfsHash).split(/%..|./).length - 1;
                if(len == 32) {
                    resolve(ipfsHash);
                } else {
                    reject('ipfs hash is the wrong length');
                }
            })
            .catch((err) => {
                reject(Error(err));
            });
        });
    }

/**
* Sends the file to the provider
* @param {provider} provider if IPFS rpc
* @param {buffer} buffer of the file object
* @return {ipfsHash} returns a single ipfsHash
*/
_sendFile(provider, buffer) {
    return new Promise((resolve, reject) => {
        
    });
}

/**
* Finds a healthy provider
* @param {providers} providers objects
* @return {Object} returns a single provider object
*/
    _healthCheck(providers) {
        return new Promise((resolve, reject) => {
        
        });
    }
/**
* Converts base 64 to an array buffer
* @param {base64} base64 string representing
* the image to be converted to an array buffer
* @return {buffer} returns an array buffer
*/
    _buffer(base64) {
        return new Promise((resolve, reject) => {
            var len = base64.length;
            var bytes = new Uint8Array( len );
            for (var i = 0; i < len; i++) {
                bytes[i] = base64.charCodeAt(i);
            }
            resolve(bytes.buffer);
        });
    }

/**
* returns a list of providers
* @return {object} returns an array of objcts containing providers.
*/
    _providers() {
        return new Promise((resolve, reject) => {
        const providers = [
            {
                id: 1,
                api: 'https://ipfs.infura.io/ipfs/',
                rpc: 'https://ipfs.infura.io:5001/api/v0/',
            },
            {
                id: 2,
                api: 'https://ipfs.io/ipfs/',
                rpc: 'https://ipfs.io:5001/api/v0/',
            },
            {
                id: 3,
                api: 'https://ipfs.swarm.city/ipfs/',
                rpc: 'https://ipfs.swarm.city:5001/api/v0',
            },
        ];
        resolve(providers);
        });
    }

        } window.customElements.define(DataIPFS.is, DataIPFS);
    </script>
</dom-module>
